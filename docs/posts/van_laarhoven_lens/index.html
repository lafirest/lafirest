<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programming Language Roam: Van Laarhoven lens | Cogito, ergo sum</title>
<meta name="keywords" content="fsharp" />
<meta name="description" content="lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。 现在最常用的 lens 实现是由 Twan van Laarhoven 发明的 CPS based functional references，原理虽然很简单， 但却相当惊艳。
这篇算是我自己的复习吧，将需要的概念都简单温习下。
getter and setter 任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。 之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型 等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持
immutable object 和 函数式语言 在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象 进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中， 任何对象几乎都是不可变的。
不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级 一直向上更新到根层级，这导致了更新的代码十分冗长。
所以有没有一种简单的方式，可以像 Cee 的指针，或者 C&#43;&#43; 的引用那样，对任意层级的任意数据进行访问和更新？
基于这种需求，lens 技术诞生了
最原始而朴素的 lens 最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中
type getter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a type setter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a -&gt; &#39;s type lens = getter * setter 当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。">
<meta name="author" content="firest">
<link rel="canonical" href="https://lafirest.github.io/posts/van_laarhoven_lens/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lafirest.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lafirest.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lafirest.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lafirest.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lafirest.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Programming Language Roam: Van Laarhoven lens" />
<meta property="og:description" content="lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。 现在最常用的 lens 实现是由 Twan van Laarhoven 发明的 CPS based functional references，原理虽然很简单， 但却相当惊艳。
这篇算是我自己的复习吧，将需要的概念都简单温习下。
getter and setter 任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。 之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型 等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持
immutable object 和 函数式语言 在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象 进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中， 任何对象几乎都是不可变的。
不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级 一直向上更新到根层级，这导致了更新的代码十分冗长。
所以有没有一种简单的方式，可以像 Cee 的指针，或者 C&#43;&#43; 的引用那样，对任意层级的任意数据进行访问和更新？
基于这种需求，lens 技术诞生了
最原始而朴素的 lens 最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中
type getter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a type setter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a -&gt; &#39;s type lens = getter * setter 当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lafirest.github.io/posts/van_laarhoven_lens/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-20T23:13:00&#43;08:00" />
<meta property="article:modified_time" content="2022-04-20T23:13:00&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Programming Language Roam: Van Laarhoven lens"/>
<meta name="twitter:description" content="lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。 现在最常用的 lens 实现是由 Twan van Laarhoven 发明的 CPS based functional references，原理虽然很简单， 但却相当惊艳。
这篇算是我自己的复习吧，将需要的概念都简单温习下。
getter and setter 任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。 之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型 等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持
immutable object 和 函数式语言 在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象 进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中， 任何对象几乎都是不可变的。
不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级 一直向上更新到根层级，这导致了更新的代码十分冗长。
所以有没有一种简单的方式，可以像 Cee 的指针，或者 C&#43;&#43; 的引用那样，对任意层级的任意数据进行访问和更新？
基于这种需求，lens 技术诞生了
最原始而朴素的 lens 最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中
type getter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a type setter&lt;&#39;s, &#39;a&gt; = &#39;s -&gt; &#39;a -&gt; &#39;s type lens = getter * setter 当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://lafirest.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Programming Language Roam: Van Laarhoven lens",
      "item": "https://lafirest.github.io/posts/van_laarhoven_lens/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Programming Language Roam: Van Laarhoven lens",
  "name": "Programming Language Roam: Van Laarhoven lens",
  "description": "lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。 现在最常用的 lens 实现是由 Twan van Laarhoven 发明的 CPS based functional references，原理虽然很简单， 但却相当惊艳。\n这篇算是我自己的复习吧，将需要的概念都简单温习下。\ngetter and setter 任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。 之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型 等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持\nimmutable object 和 函数式语言 在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象 进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中， 任何对象几乎都是不可变的。\n不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级 一直向上更新到根层级，这导致了更新的代码十分冗长。\n所以有没有一种简单的方式，可以像 Cee 的指针，或者 C++ 的引用那样，对任意层级的任意数据进行访问和更新？\n基于这种需求，lens 技术诞生了\n最原始而朴素的 lens 最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中\ntype getter\u0026lt;\u0026#39;s, \u0026#39;a\u0026gt; = \u0026#39;s -\u0026gt; \u0026#39;a type setter\u0026lt;\u0026#39;s, \u0026#39;a\u0026gt; = \u0026#39;s -\u0026gt; \u0026#39;a -\u0026gt; \u0026#39;s type lens = getter * setter 当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。",
  "keywords": [
    "fsharp"
  ],
  "articleBody": "lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。 现在最常用的 lens 实现是由 Twan van Laarhoven 发明的 CPS based functional references，原理虽然很简单， 但却相当惊艳。\n这篇算是我自己的复习吧，将需要的概念都简单温习下。\ngetter and setter 任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。 之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型 等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持\nimmutable object 和 函数式语言 在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象 进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中， 任何对象几乎都是不可变的。\n不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级 一直向上更新到根层级，这导致了更新的代码十分冗长。\n所以有没有一种简单的方式，可以像 Cee 的指针，或者 C++ 的引用那样，对任意层级的任意数据进行访问和更新？\n基于这种需求，lens 技术诞生了\n最原始而朴素的 lens 最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中\ntype getter's, 'a = 's - 'a type setter's, 'a = 's - 'a - 's type lens = getter * setter 当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。\n这种方式虽然十分简单，但是并不高效，而且缺乏多态支持，实际使用上很受限，所以早期的 lens 技术长期没有热度，直到 van Laarhoven lens 的出现，lens 技术才变得十分强大。\nVan Laarhoven lens 首先，van Laarhoven lens 的代码定义如下:\ntype getter's, 'a = 's - 'a type setter's, 'a = 's - 'a - 's type lens = fun f s - fmap (setter s) (f (getter s))  // 其中 f 是一个 Functor // fmap相当于是 Functor 上的 map // 使用 Haskell 定义则相当简洁 // lens :: (s - a) - (s - a - s) - Lens s a // lens getter setter = \\f s - setter s  f (getter s) 关于 van Laarhoven lens 的大部分讲解都是围绕如何将 getter 和 setter 通过一系列操作统一在一个函数内，且转换为 上面的定义格式，但是我觉得这种方式很难理解。而反过来先看定义，再分析为什么这一个函数可以同时实现访问和写入，反而更容易理解些。\n要理解 van Laarhoven lens 需要先理解两个函子(Functor):\nFunctor 函子 是范畴上的同态，可以看作是集合上的 map 的升级版, 参考 map :\n// map 接受一个映射函数，然后将 a 映射到 b上 map : ('a - 'b) - 'a - 'b  // 函子的 fmap 也一样，只不过操作对象变成了函子 fmap : ('a - 'b) - F 'a - F 'b Identity functor 恒等函子 将一个范畴上的对象和态射始终映射到它门自身，可以通过集合上的 identity function 进行理解:\n// 恒等函数始终将任意对象映射为其自身 let identity x = x Constant functor 常数函子 将范畴 C 上的所有对象映射到范畴 D 上的某个固定对象，且将范畴 C 上的所有态射映射为这个固定对象的恒等态射， 同样，这个函子可以通过集合上的 constant function 进行理解:\n// 常数函数无论接受任何输入，始终都返回的是一个固定值 // 定义2更准确些，但是因为 fsharp 支持 partial application，所以两个实际上是等价的 let constant a b = a // 或者 let mkConstant a = fun _ - a 访问 有了上面的背景知识介绍，就能开始说明，访问和更新是如何实现的。\n更新十分简单，将 Constant functor 带入 lens 定义即可:\n// getConst : Const a b - a // getConst 相当于从 Constant 函子中取出那个固定的对象 let view lens s = getConst (lens Const s) 先抛除 getConst，分析下剩余部分发生了什么:\nlens Const s =\nfmap (setter s) (Const (getter s))\n getter s 能够取到需要访问的数据 x， 生成常数函子 Const x 根据常数函子的性质可知, fmap (setter s) (Const x) = Const x getConst (Const x) 得到 x  更新 更新的定义如下:\n// f 是一个更新函数, f : 'a - 'a // f  Identity = fun x - Identity (f x) let over f s = getIdentity (lens (f  Identity) s 同样的，先不管 getIdentity，分析下剩余的部分:\nlens (f  Identity) s =\nfmap (setter s) (Identity (f (getter s)))\n getter s 取出需要更新的旧值 将旧值应用到更新函数 f 上，得到更新后的值 x 生成恒等函子 Identity x fmap (setter s) (Identity x) = Identity (setter s x) setter s x 得到更新后的对象 y getIdentity (Identity y) 得到更新后的对象 y  实现 上面的所有操作在 Haskell 中实现是最简洁的，但是因为 Haskell 高度抽象的原因，反而会隐藏掉许多需要理解的细节\n这里我用 fsharp 实现了一份，然后写的真的痛苦。。。许多地方不加类型标注将会得到奇奇怪怪的编译错误\n// 注意:这里的缩进可能在导出时会发生改变，直接复制粘贴可能无法通过编译 module Lens  // fsharp 没有 Type Class，所以这里使用接口实现 type IFunctor'a =  abstract fmap : ('a - 'b) - IFunctor'b  // Const 有两个构造参数，其中 b 是幻影类型 // 然后就是 Const 并不是函子, Const类似于 Haskell 中 Const a b // 在 Const a b 中, (Const a) 才是函子，所以这里的 fmap 里面实际上有三个类型参数 // 可以参考上面的常量函数 const a b 中，(const a) 才是真正的常量函数 type Const'a, 'b = Const of 'a interface IFunctor'b with  // 常量函子 (Const 'a) 在维持对 'a 的固定的情况下，将任何 'b 映射为 'c  // 这个 fmap 中虽然看起来什么都没干, 实际上的操作发生在幻影类型上  // fmap :: ('b - 'c) - Const 'a 'b - Const 'a 'c, 更准确的说是  // fmap :: ('b - 'c) - F 'b - F 'c  // 其中 F = Const 'a  member this.fmap _ =  let (Const c) = this in Const c : IFunctor'c  // 恒等函子将任意 'a 映射为其自身 type Identity'a = Identity of 'a interface IFunctor'a with  member this.fmap (f : 'a - 'b) =  let (Identity id) = this in  f id | Identity : IFunctor'b  // 辅助函数 let fmap'a, 'b f (F : IFunctor'a) = F.fmap f : IFunctor'b  // lens 的定义，实际没多少内容，主要是类型标注加太多，但是不加的话，编译器会推导出奇奇怪怪的结果 let inline mkLens (getter : 's - 'a) (setter : 's - 'b - 'c) =  fun (f : 'a - IFunctor'b) (s : 's) - fmap (setter s) (f (getter s)) : IFunctor'c  // 访问的定义，除了类型标注外，类型转换也挺烦人的 let view'a, 's  (lens : ('a - IFunctor'a) - 's - IFunctor's)  (s : 's) =  let toFunctor = fun x - Const x : IFunctor'a  let (Const c) = lens toFunctor s :? Const'a, 's in  c  // 更新的定义 let over'a, 's  (lens : ('a - IFunctor'a) - 's - IFunctor's)  f  s =  let toFunctor = fun x - Identity x : IFunctor'a  let (Identity r) = (lens (f  toFunctor) s) :? Identity's in  r 示例 open System open Lens  // Skill 类型模拟深层级数据 type Skill = {  Damage : int  }  // Monster 持有一个 Skill 类型 type Monster = {  Name : string  Level : int  Skill : Skill  }  [EntryPoint] let main argv =  // Monster 上 Skill 的 Lens  let skillLens = mkLens (fun s - s.Skill) (fun s a - {s with Skill = a} )   // Skill 上 Damage 的 Lens  let damageLens = mkLens (fun s - s.Damage) (fun s a - {s with Damage = a} )   // 复合，生成从 Monster 上访问、修改 Damage 的 Lens  let lens = damageLens  skillLens   let skill = {Damage = 100}  let monster = {Name = \"Monster\"; Level = 14; Skill = skill}   // 访问  view lens monster | printfn \"Get Damage is: %O\"   // 修改  over lens (fun _ - 999) monster  | printfn \"Update Damage, New Monster is: %O\"   0 // return an integer exit code 结果：\nGet Damage is: 100 Update Damage, New Monster is: { Name = \"Monster\"  Level = 14  Skill = { Damage = 999 } } 实际上成熟的 lens 库不会这么复杂的进行操作，使用起来的效果最终和命令式语言类似，而且 lens 也并不仅仅只是拿来进行数据的 访问和修改，不过其他部分需要理解的地方更多了，暂时还没时间，哈哈。\n",
  "wordCount" : "894",
  "inLanguage": "en",
  "datePublished": "2022-04-20T23:13:00+08:00",
  "dateModified": "2022-04-20T23:13:00+08:00",
  "author":{
    "@type": "Person",
    "name": "firest"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lafirest.github.io/posts/van_laarhoven_lens/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cogito, ergo sum",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lafirest.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lafirest.github.io" accesskey="h" title="Cogito, ergo sum (Alt + H)">Cogito, ergo sum</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lafirest.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://lafirest.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://lafirest.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lafirest.github.io">Home</a>&nbsp;»&nbsp;<a href="https://lafirest.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Programming Language Roam: Van Laarhoven lens
    </h1>
    <div class="post-meta"><span title='2022-04-20 23:13:00 +0800 CST'>April 20, 2022</span>&nbsp;·&nbsp;firest

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#getter-and-setter" aria-label="getter and setter">getter and setter</a></li>
                <li>
                    <a href="#immutable-object-%e5%92%8c-%e5%87%bd%e6%95%b0%e5%bc%8f%e8%af%ad%e8%a8%80" aria-label="immutable object 和 函数式语言">immutable object 和 函数式语言</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%8e%9f%e5%a7%8b%e8%80%8c%e6%9c%b4%e7%b4%a0%e7%9a%84-lens" aria-label="最原始而朴素的 lens">最原始而朴素的 lens</a></li>
                <li>
                    <a href="#van-laarhoven-lens" aria-label="Van Laarhoven lens">Van Laarhoven lens</a><ul>
                        
                <li>
                    <a href="#functor" aria-label="Functor">Functor</a></li>
                <li>
                    <a href="#identity-functor" aria-label="Identity functor">Identity functor</a></li>
                <li>
                    <a href="#constant-functor" aria-label="Constant functor">Constant functor</a></li>
                <li>
                    <a href="#%e8%ae%bf%e9%97%ae" aria-label="访问">访问</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0" aria-label="更新">更新</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a></li>
                <li>
                    <a href="#%e7%a4%ba%e4%be%8b" aria-label="示例">示例</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>lens 是一种函数式引用，可以实现对数据的任意部分进行访问和修改，宽松点说，lens 可以看作是一种函数式「指针」。
现在最常用的 lens 实现是由 <a href="https://twanvl.nl/">Twan van Laarhoven</a> 发明的 <a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">CPS based functional references</a>，原理虽然很简单，
但却相当惊艳。</p>
<p>这篇算是我自己的复习吧，将需要的概念都简单温习下。</p>
<h2 id="getter-and-setter">getter and setter<a hidden class="anchor" aria-hidden="true" href="#getter-and-setter">#</a></h2>
<p>任何一个可以读写的数据都至少有两个操作:读和写，对数据的读和写进行封装，以函数的方式对外提供的操作一般称作「getter」和「setter」。
之所以需要对读/写进行封装，是因为很多场景下，数据的写入往往伴随着一定的副作用，而对读进行封装，则可以实现延迟计算、单例模型
等功能。大部分现代编程语言，比如 C#，都在语法层面提供了简洁的 getter/setter 支持</p>
<h2 id="immutable-object-和-函数式语言">immutable object 和 函数式语言<a hidden class="anchor" aria-hidden="true" href="#immutable-object-和-函数式语言">#</a></h2>
<p>在部分编程语言中存在不可变对象，比如在区分「值类型」和「引用类型」的编程语言中，值类型一般就是不可变的。对不可变对象
进行更新操作，一般都是先复制出一个新的副本，然后将更新的值作用在这个副本之上，从而得到更新后的对象。而在大多数函数式语言中，
任何对象几乎都是不可变的。</p>
<p>不可变特性导致了一个很难受的问题：对复杂数据，尤其是层级很深的数据进行更新将是灾难性的，每次更新实际上都需要从当前层级
一直向上更新到根层级，这导致了更新的代码十分冗长。</p>
<p>所以有没有一种简单的方式，可以像 Cee 的指针，或者 C++ 的引用那样，对任意层级的任意数据进行访问和更新？</p>
<p>基于这种需求，lens 技术诞生了</p>
<h2 id="最原始而朴素的-lens">最原始而朴素的 lens<a hidden class="anchor" aria-hidden="true" href="#最原始而朴素的-lens">#</a></h2>
<p>最早期的 lens 技术十分朴素：将 getter 和 setter 放在一个元组中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">getter</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">setter</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lens</span> <span style="color:#f92672">=</span> getter <span style="color:#f92672">*</span> setter
</span></span></code></pre></div><p>当需要对一个字段进行操作时，只需要将从根目录到该字段沿途所有的这种 lens 元组，进行函数复合即可。</p>
<p>这种方式虽然十分简单，但是并不高效，而且缺乏多态支持，实际使用上很受限，所以早期的 lens 技术长期没有热度，直到
van Laarhoven lens 的出现，lens 技术才变得十分强大。</p>
<h2 id="van-laarhoven-lens">Van Laarhoven lens<a hidden class="anchor" aria-hidden="true" href="#van-laarhoven-lens">#</a></h2>
<p>首先，van Laarhoven lens 的代码定义如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">getter</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">setter</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lens</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> f s <span style="color:#f92672">-&gt;</span> fmap <span style="color:#f92672">(</span>setter s<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>f <span style="color:#f92672">(</span>getter s<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 其中 f 是一个 Functor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// fmap相当于是 Functor 上的 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 Haskell 定义则相当简洁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// lens :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; Lens s a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// lens getter setter = \f s -&gt; setter s &lt;$&gt; f (getter s)
</span></span></span></code></pre></div><p>关于 van Laarhoven lens 的大部分讲解都是围绕如何将 getter 和 setter 通过一系列操作统一在一个函数内，且转换为
上面的定义格式，但是我觉得这种方式很难理解。而反过来先看定义，再分析为什么这一个函数可以同时实现访问和写入，反而更容易理解些。</p>
<p>要理解 van Laarhoven lens 需要先理解两个函子(Functor):</p>
<h3 id="functor">Functor<a hidden class="anchor" aria-hidden="true" href="#functor">#</a></h3>
<p><a href="https://ncatlab.org/nlab/show/functor">函子</a> 是范畴上的同态，可以看作是集合上的 map 的升级版, 参考 map :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// map 接受一个映射函数，然后将 a 映射到 b上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>map <span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函子的 fmap 也一样，只不过操作对象变成了函子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fmap <span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> F <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> F <span style="color:#66d9ef">&#39;</span>b
</span></span></code></pre></div><h3 id="identity-functor">Identity functor<a hidden class="anchor" aria-hidden="true" href="#identity-functor">#</a></h3>
<p><a href="https://ncatlab.org/nlab/show/identity+functor">恒等函子</a> 将一个范畴上的对象和态射始终映射到它门自身，可以通过集合上的 identity function 进行理解:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// 恒等函数始终将任意对象映射为其自身
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> identity x <span style="color:#f92672">=</span> x
</span></span></code></pre></div><h3 id="constant-functor">Constant functor<a hidden class="anchor" aria-hidden="true" href="#constant-functor">#</a></h3>
<p><a href="https://ncatlab.org/nlab/show/constant+functor">常数函子</a> 将范畴 C 上的所有对象映射到范畴 D 上的某个固定对象，且将范畴 C 上的所有态射映射为这个固定对象的恒等态射，
同样，这个函子可以通过集合上的 constant function 进行理解:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// 常数函数无论接受任何输入，始终都返回的是一个固定值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义2更准确些，但是因为 fsharp 支持 partial application，所以两个实际上是等价的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> constant a b <span style="color:#f92672">=</span> a
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> mkConstant a <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> a
</span></span></code></pre></div><h3 id="访问">访问<a hidden class="anchor" aria-hidden="true" href="#访问">#</a></h3>
<p>有了上面的背景知识介绍，就能开始说明，访问和更新是如何实现的。</p>
<p>更新十分简单，将 Constant functor 带入 lens 定义即可:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// getConst : Const a b -&gt; a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// getConst 相当于从 Constant 函子中取出那个固定的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> view lens s <span style="color:#f92672">=</span> getConst <span style="color:#f92672">(</span>lens Const s<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>先抛除 getConst，分析下剩余部分发生了什么:</p>
<p>lens Const s =</p>
<p>fmap (setter s) (Const (getter s))</p>
<ol>
<li>getter s 能够取到需要访问的数据 x，</li>
<li>生成常数函子 Const x</li>
<li>根据常数函子的性质可知, fmap (setter s) (Const x) = Const x</li>
<li>getConst (Const x) 得到 x</li>
</ol>
<h3 id="更新">更新<a hidden class="anchor" aria-hidden="true" href="#更新">#</a></h3>
<p>更新的定义如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// f 是一个更新函数, f : &#39;a -&gt; &#39;a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// f &gt;&gt; Identity = fun x -&gt; Identity (f x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> over f s <span style="color:#f92672">=</span> getIdentity <span style="color:#f92672">(</span>lens <span style="color:#f92672">(</span>f <span style="color:#f92672">&gt;&gt;</span> Identity<span style="color:#f92672">)</span> s
</span></span></code></pre></div><p>同样的，先不管 getIdentity，分析下剩余的部分:</p>
<p>lens (f &gt;&gt; Identity) s =</p>
<p>fmap (setter s) (Identity (f (getter s)))</p>
<ol>
<li>getter s 取出需要更新的旧值</li>
<li>将旧值应用到更新函数 f 上，得到更新后的值 x</li>
<li>生成恒等函子 Identity x</li>
<li>fmap (setter s) (Identity x) = Identity (setter s x)</li>
<li>setter s x 得到更新后的对象 y</li>
<li>getIdentity (Identity y) 得到更新后的对象 y</li>
</ol>
<h2 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h2>
<p>上面的所有操作在 Haskell 中实现是最简洁的，但是因为 Haskell 高度抽象的原因，反而会隐藏掉许多需要理解的细节</p>
<p>这里我用 fsharp 实现了一份，然后写的真的痛苦。。。许多地方不加类型标注将会得到奇奇怪怪的编译错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// 注意:这里的缩进可能在导出时会发生改变，直接复制粘贴可能无法通过编译
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">module</span> Lens
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// fsharp 没有 Type Class，所以这里使用接口实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IFunctor</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> fmap <span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Const 有两个构造参数，其中 b 是幻影类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 然后就是 Const 并不是函子, Const&lt;&#39;a, &#39;b&gt; 类似于 Haskell 中 Const a b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 在 Const a b 中, (Const a) 才是函子，所以这里的 fmap 里面实际上有三个类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以参考上面的常量函数 const a b 中，(const a) 才是真正的常量函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Const</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>Const <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">interface</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 常量函子 (Const &#39;a) 在维持对 &#39;a 的固定的情况下，将任何 &#39;b 映射为 &#39;c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这个 fmap 中虽然看起来什么都没干, 实际上的操作发生在幻影类型上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// fmap :: (&#39;b -&gt; &#39;c) -&gt; Const &#39;a &#39;b -&gt; Const &#39;a &#39;c, 更准确的说是
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// fmap :: (&#39;b -&gt; &#39;c) -&gt; F &#39;b -&gt; F &#39;c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 其中 F = Const &#39;a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">member</span> this.<span style="color:#a6e22e">fmap</span> <span style="color:#f92672">_</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>Const c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> this <span style="color:#66d9ef">in</span> Const c <span style="color:#f92672">:&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 恒等函子将任意 &#39;a 映射为其自身
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Identity</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>Identity <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">interface</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">member</span> this.<span style="color:#a6e22e">fmap</span> <span style="color:#f92672">(</span>f <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>Identity id<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> this <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                f id <span style="color:#f92672">|&gt;</span> Identity <span style="color:#f92672">:&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 辅助函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> fmap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span> f <span style="color:#f92672">(</span>F <span style="color:#f92672">:</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span> F.fmap f <span style="color:#f92672">:</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// lens 的定义，实际没多少内容，主要是类型标注加太多，但是不加的话，编译器会推导出奇奇怪怪的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> inline mkLens <span style="color:#f92672">(</span>getter <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>setter <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>f <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> fmap <span style="color:#f92672">(</span>setter s<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>f <span style="color:#f92672">(</span>getter s<span style="color:#f92672">))</span> <span style="color:#f92672">:</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问的定义，除了类型标注外，类型转换也挺烦人的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> view<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>lens <span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>s <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> toFunctor <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> Const x <span style="color:#f92672">:&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>Const c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> lens toFunctor s <span style="color:#f92672">:?&gt;</span> Const<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 更新的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> over<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>lens <span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>s <span style="color:#f92672">-&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;)</span>
</span></span><span style="display:flex;"><span>    f
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> toFunctor <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> Identity x <span style="color:#f92672">:&gt;</span> IFunctor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>Identity r<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>  <span style="color:#f92672">(</span>lens <span style="color:#f92672">(</span>f <span style="color:#f92672">&gt;&gt;</span> toFunctor<span style="color:#f92672">)</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">:?&gt;</span> Identity<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>s<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        r
</span></span></code></pre></div><h2 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">open</span> System
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> Lens
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Skill 类型模拟深层级数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Skill</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Damage <span style="color:#f92672">:</span> int
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Monster 持有一个 Skill 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Monster</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Name <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    Level <span style="color:#f92672">:</span> int
</span></span><span style="display:flex;"><span>    Skill <span style="color:#f92672">:</span> Skill
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[&lt;</span>EntryPoint<span style="color:#f92672">&gt;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> main argv <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Monster 上 Skill 的 Lens
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> skillLens <span style="color:#f92672">=</span> mkLens <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span>Skill<span style="color:#f92672">)</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> s a <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>s <span style="color:#66d9ef">with</span> Skill <span style="color:#f92672">=</span> a<span style="color:#f92672">}</span> <span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Skill 上 Damage 的 Lens
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> damageLens <span style="color:#f92672">=</span> mkLens <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span>Damage<span style="color:#f92672">)</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> s a <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>s <span style="color:#66d9ef">with</span> Damage <span style="color:#f92672">=</span> a<span style="color:#f92672">}</span> <span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 复合，生成从 Monster 上访问、修改 Damage 的 Lens
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> lens <span style="color:#f92672">=</span> damageLens <span style="color:#f92672">&gt;&gt;</span> skillLens
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> skill <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>Damage <span style="color:#f92672">=</span> 100<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> monster <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>Name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Monster&#34;</span><span style="color:#f92672">;</span> Level <span style="color:#f92672">=</span> 14<span style="color:#f92672">;</span> Skill <span style="color:#f92672">=</span> skill<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    view lens monster <span style="color:#f92672">|&gt;</span> printfn <span style="color:#e6db74">&#34;Get Damage is: %O&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    over lens <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> 999<span style="color:#f92672">)</span> monster
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;</span> printfn <span style="color:#e6db74">&#34;Update Damage, New Monster is: %O&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    0 <span style="color:#75715e">// return an integer exit code
</span></span></span></code></pre></div><p>结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Get Damage is: <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>Update Damage, New Monster is: <span style="color:#f92672">{</span> Name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Monster&#34;</span>
</span></span><span style="display:flex;"><span>                                 Level <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>                                 Skill <span style="color:#f92672">=</span> <span style="color:#f92672">{</span> Damage <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span> <span style="color:#f92672">}</span> <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>实际上成熟的 lens 库不会这么复杂的进行操作，使用起来的效果最终和命令式语言类似，而且 lens 也并不仅仅只是拿来进行数据的
访问和修改，不过其他部分需要理解的地方更多了，暂时还没时间，哈哈。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lafirest.github.io/tags/fsharp/">fsharp</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://lafirest.github.io/posts/load_time_calculation/">
    <span class="title">Next Page »</span>
    <br>
    <span>Programming Language Roam: Load-Time Calculation</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://lafirest.github.io">Cogito, ergo sum</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
